"zannat""movie_recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KbYCYyO6NcfTqF0YsuGLkBhYW1YDx_Mf
"""

from google.colab import drive
drive.mount('/content/drive')

# Import necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from IPython.display import display

# Load the datasets
movies_file = 'movies.csv'  # Update with your movies file path
ratings_file = 'ratings.csv'  # Update with your ratings file path

movies = pd.read_csv(movies_file)
ratings = pd.read_csv(ratings_file)

# Preprocess the movies dataset
movies['title'] = movies['title'].fillna('')

# Build a TF-IDF matrix for movie titles
vectorizer = TfidfVectorizer(ngram_range=(1, 2), stop_words='english')
tfidf_matrix = vectorizer.fit_transform(movies['title'])

# Function to search movies based on title similarity
def search_movies(title, top_n=5):
    query_vec = vectorizer.transform([title])
    similarity = cosine_similarity(query_vec, tfidf_matrix).flatten()
    indices = np.argpartition(similarity, -top_n)[-top_n:]
    results = movies.iloc[indices].iloc[::-1]
    return results[['movieId', 'title']]

# Function to get movie details by title
def get_movie_details(title):
    movie = movies[movies['title'].str.contains(title, case=False, na=False)]
    if not movie.empty:
        return movie
    else:
        return pd.DataFrame({'Message': ["No matching movie found."]})

# Function to find user-based recommendations
def find_user_recommendations(movie_id):
    similar_users = ratings[(ratings['movieId'] == movie_id) & (ratings['rating'] > 4)]['userId'].unique()
    similar_user_recs = ratings[(ratings['userId'].isin(similar_users)) & (ratings['rating'] > 4)]['movieId']
    similar_user_recs = similar_user_recs.value_counts() / len(similar_users)
    similar_user_recs = similar_user_recs[similar_user_recs > 0.1]

    all_users = ratings[(ratings['movieId'].isin(similar_user_recs.index)) & (ratings['rating'] > 4)]
    all_user_recs = all_users['movieId'].value_counts() / len(all_users['userId'].unique())

    rec_scores = pd.concat([similar_user_recs, all_user_recs], axis=1, keys=['similar', 'all'])
    rec_scores['score'] = rec_scores['similar'] / rec_scores['all']
    rec_scores = rec_scores.sort_values('score', ascending=False)

    recommendations = rec_scores.head(10).merge(movies, left_index=True, right_on='movieId')[['score', 'title']]
    return recommendations

# Visualization of ratings distribution
def plot_ratings_distribution():
    plt.figure(figsize=(10, 6))
    plt.hist(ratings['rating'], bins=10, color='blue', edgecolor='black')
    plt.title('Ratings Distribution')
    plt.xlabel('Rating')
    plt.ylabel('Count')
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.show()

# Example usage
if __name__ == '__main__':
    # Plot the ratings distribution
    try:
        plot_ratings_distribution()
    except Exception as e:
        print(f"Error displaying plot: {e}")

    # Search for movies
    try:
        search_title = "Toy Story"
        print("Searching for:", search_title)
        search_results = search_movies(search_title)
        print("\nSearch Results:")
        display(search_results)
    except Exception as e:
        print(f"Error fetching search results: {e}")

    # Get movie details
    try:
        print("\nMovie Details:")
        movie_details = get_movie_details(search_title)
        display(movie_details)
    except Exception as e:
        print(f"Error fetching movie details: {e}")

    # Recommendations
    try:
        movie_id_example = 1  # Replace with a valid movieId for testing
        print("\nRecommendations:")
        recommendations = find_user_recommendations(movie_id_example)
        display(recommendations)
    except Exception as e:
        print(f"Error generating recommendations: {e}")